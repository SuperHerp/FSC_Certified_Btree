import java.io.File;
import java.util.ArrayList;

/**
 * This class represents a node of a B-tree. For a detailed specification of the B-tree properties to be used here, please refer to the description of the {@link AbstractBTree} class.
 *
 * @see AbstractBTree
 * @see <a href="https://de.wikipedia.org/wiki/B-Baum">B-Tree (Wikipedia)</a>
 */
public abstract class AbstractBTreeNode {
	/**
	 * BTree containing this node
	 */
	private AbstractBTree bTree;
	/**
	 * The degree of this BTreeNode. It must be the same for all nodes of the tree to which this node belongs to.
	 *
	 * @see AbstractBTree
	 */
	private final int degree;
	/**
	 * The list of keys stored in this node.
	 *
	 * @see AbstractBTree
	 */
	private final ArrayList<FileContainer> keys = new ArrayList<>();
	/**
	 * The list of children (subtrees) of this node.
	 *
	 * @see AbstractBTree
	 */
	private final ArrayList<AbstractBTreeNode> children = new ArrayList<>();

	/**
	 * Creates a new BTreeNode with given {@link #degree}.
	 *
	 * @param degree the degree of the new BTreeNode
	 */
	public AbstractBTreeNode(int degree, AbstractBTree bTree) {
		this.degree = degree;
		this.bTree = bTree;
		//System.out.println("Constructor: " + children.hashCode());
	}

	public final AbstractBTree get_bTree(){
		return this.bTree;
	}

	public final void set_bTree(AbstractBTree bTree){
		this.bTree = bTree;
	}

	/**
	 * Returns the {@link #degree} of this BTreeNode
	 *
	 * @return the {@link #degree} of this BTreeNode
	 * @see AbstractBTree#getDegree()
	 */
	public final int getDegree() {
		return degree;
	}

	/**
	 * Returns the {@link #keys} of this BTreeNode.
	 *
	 * @return the {@link #keys} of this BTreeNode.
	 */
	public final ArrayList<FileContainer> getKeys() {
		return keys;
	}

	/**
	 * Returns the {@link #children} of this BTreeNode.
	 *
	 * @return the {@link #children} of this BTreeNode.
	 */
	public final ArrayList<AbstractBTreeNode> getChildren() {
		return children;
	}

	/**
	 * Appends the given key to the list of {@link #keys} of this BTreeNode.
	 *
	 * @param key the value to be appended to the list of {@link #keys} of this BTreeNode
	 */
	public final void addKey(FileContainer key) {
		keys.add(key);
	}

	/**
	 * Appends the given child to the list of {@link #children} of this BTreeNode.
	 *
	 * @param child the subtree to be appended to the list of {@link #children} of this BTreeNode
	 */
	public final void addChild(AbstractBTreeNode child) {
		children.add(child);
	}

	/**
	 * Returns {@literal true} if this BTreeNode is the root of a BTree which contains the specified element.
	 * This method <b>recursively</b> traverses the BTree rooted at this BTreeNode searching for the specified element.
	 *
	 * @param key element whose presence in the BTree rooted at this BTreeNode is to be tested
	 * @return {@literal true} if the BTree rooted at this BTreeNode contains the specified element
	 */
	public abstract boolean hasKey(String key);

	/**
	 * sorts FileContainer list
	 *
	 * @return sorted FileContainerList
	 */
	public abstract ArrayList<FileContainer> sort(ArrayList<FileContainer> toSort);

	/**
	 * <b>Recursively</b> inserts the given key into the BTree rooted at this BTreeNode.
	 * <p>
	 * New keys are <b>always</b> inserted into <b>leaf nodes first</b>!
	 * </p>
	 * <p>
	 * If this node has more than 2x {@link #degree} keys after the <b>recursive</b> insertion, then this node must be split using the {@link #split()} method.
	 * In this case the {@link OverflowNode} generated by {@link #split()} is returned and must be processed at higher level.
	 * </p>
	 * <p>
	 * If the recursive call used to insert the new key into a child subtree returns an {@link OverflowNode} then
	 * the {@link OverflowNode#getKey()} is inserted into the current node at proper position and the {@link OverflowNode#getRightChild()} becomes the right child of this newly inserted key.
	 * </p>
	 * <p>
	 * <b>Note</b> that adding the value of an {@link OverflowNode} to the current BTreeNode may require this node to split itself.
	 * Such <b>recursive</b> splitting might reach up to the root of the BTree, requiring the entire tree to level up.
	 * </p>
	 * The keys in the list of {@link #keys} of each node <b>must always</b> be kept <b>sorted in ascending order</b>!
	 *
	 * @param key the value to be inserted into this BTree
	 * @return the {@link OverflowNode} generated by {@link #split()} if this node had to be split or {@literal null} otherwise
	 * @see AbstractBTreeNode#split()
	 */
	public abstract OverflowNode insert(FileContainer key);

	/**
	 * If a BTreeNode has more than 2x {@link #degree} keys, it is said to overflow and must be split. A node can overflow in two cases:
	 * <ul>
	 *     <li>it is a leaf that already contained 2x {@link #degree} keys and a new key had to be inserted.</li>
	 *     <li>it is an inner node that already contained 2x {@link #degree} keys and the recursive insertion into a child returned an {@link OverflowNode}.</li>
	 * </ul>
	 * This method splits this node as follows:
	 * <ul>
	 *     <li>the <b>first</b> {@link #degree} keys and their children remain in this node.</li>
	 *     <li>the <b>middle</b> key of this node is transferred (i.e. moved and deleted from this node) to a newly created {@link OverflowNode} - it can be recalled using {@link OverflowNode#getKey()} from there.</li>
	 *     <li>the <b>last</b> {@link #degree} keys and their children are transferred (i.e. moved and deleted from this node) into a newly created {@link AbstractBTreeNode}, which is placed into the {@link OverflowNode} mentioned above - it can be recalled using {@link OverflowNode#getRightChild()} from there.</li>
	 * </ul>
	 *
	 * @return an {@link OverflowNode} containing the middle key ({@link OverflowNode#getKey()}) and the right half of this node ({@link OverflowNode#getRightChild()}).
	 */
	public abstract OverflowNode split();

	/**
	 * Returns a string representation of this BTreeNode in the JSON format without considering white spaces or other layout.
	 * <p>
	 * An object with attributes attr<sub>1</sub> = value<sub>1</sub>, attr<sub>2</sub> = value<sub>2</sub>, ..., attr<sub>n</sub> = value<sub>n</sub>
	 * is encoded as a comma separated sequence of key-value pairs enclosed in curly brackets,
	 * where each key is the name of the attribute and the corresponding value is the current value of that attribute:
	 * <samp>"{attr<sub>1</sub>: value<sub>1</sub>, attr<sub>2</sub>: value<sub>2</sub>, ..., attr<sub>n</sub>: value<sub>n</sub>}"</samp>.
	 * If an attribute is {@literal null} then the attribute is omitted entirely from the JSON string.
	 * </p>
	 * <p>
	 * Lists and arrays are encoded by enumerating their values within square brackets, i.e. <samp>"[0,1,2,3,4]"</samp>.
	 * </p>
	 * <b>Example:</b>
	 * <p>The following BTree of {@link #degree} 4 with root keys <kbd>[9,22]</kbd>:</p>
	 * <div style="background-color:white;">
	 * <kbd><span style="color:white">_______________</span>[9,22,-,-]<span style="color:white">____________________</span></kbd><br/>
	 * <kbd><span style="color:white">______________</span>/<span style="color:white">__</span>|<span style="color:white">__</span>\<span style="color:white">________________________</span></kbd><br/>
	 * <kbd><span style="color:white">___</span>/---------/<span style="color:white">___</span>|<span style="color:white">___</span>\---------\<span style="color:white">_____________</span></kbd><br/>
	 * <kbd><span style="color:white">__</span>/<span style="color:white">______________</span>|<span style="color:white">______________</span>\<span style="color:white">____________</span></kbd><br/>
	 * <kbd><span style="color:white">_</span>[2,8,-,-]<span style="color:white">_______</span>[17,21,-,-]<span style="color:white">____</span>[23,24,25,-]<span style="color:white">_</span></kbd><br/>
	 * </div>
	 * <p>is <b>recursively</b> encoded to the following JSON string:</p>
	 * <div style="background-color:white;">
	 * <samp>{
	 * <samp><span style="color:white">____[9, 22],
	 * <samp><span style="color:white">____
	 * <samp><span style="color:white">____[
	 * <samp><span style="color:white">________{
	 * <samp><span style="color:white">____________[2, 8]
	 * <samp><span style="color:white">________},
	 * <samp><span style="color:white">________{
	 * <samp><span style="color:white">____________[17, 21]
	 * <samp><span style="color:white">________},
	 * <samp><span style="color:white">________{
	 * <samp><span style="color:white">____________[23, 24, 25]
	 * <samp><span style="color:white">________}
	 * <samp><span style="color:white">____]
	 * <samp>}
	 * </div>
	 *  [9,22],[{[2,8]},{[17,21]},{[23,24,25]}]
	 * @return a string representation of this BTree in the JSON format
	 * @see <a href="https://de.wikipedia.org/wiki/JavaScript_Object_Notation">JavaScript Object Notation (JSON)</a>
	 */
	public abstract String toJson();
}